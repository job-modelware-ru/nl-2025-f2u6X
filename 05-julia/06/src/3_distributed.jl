# using Distributed — подключает модуль для распределённых вычислений
# Многопроцессность: каждый процесс имеет свою память
using Distributed

# addprocs(2) — добавляет 2 рабочих процесса к основному
# Процессы могут быть на том же компьютере или на удалённых узлах
addprocs(2)

# @everywhere — выполняет код на ВСЕХ процессах (основном и рабочих)
# Необходимо для определения функций и данных на всех процессах
@everywhere function heavy_computation(x)
    # Имитация тяжёлых вычислений — каждая итерация независима
    sleep(0.1) # Блокирующая операция
    return x * x # Возвращает квадрат числа
end

# @distributed — распределяет итерации цикла по рабочим процессам
# (+) — операция редукции (сложения) для объединения результатов
result = @distributed (+) for x in 1:10
    heavy_computation(x) # Каждая итерация выполняется на своём процессе
end
println("Сумма квадратов (параллельно): ", result)

# Альтернативный способ с явным указанием функции редукции
@everywhere function custom_reduce(a, b)
    return a + b # Пользовательская операция редукции
end
result2 = @distributed custom_reduce for x in 1:5
    x * x * x # Вычисляем кубы
end
println("Сумма кубов: ", result2)